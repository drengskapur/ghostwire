version: '3'

dotenv: ['.env', '.env.local']

env:
  VERSION:
    sh: grep '^version:' chart/Chart.yaml | awk '{print $2}'
  CHART_NAME:
    sh: grep '^name:' chart/Chart.yaml | awk '{print $2}'
  REGISTRY: '{{.REGISTRY | default "ghcr.io"}}'
  NAMESPACE: '{{.NAMESPACE | default "drengskapur/ghostwire"}}'

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  claude:
    desc: Run Claude Code
    silent: true
    cmds:
      - claude --dangerously-skip-permissions

  resume:
    desc: Resume Claude Code session
    silent: true
    cmds:
      - claude --dangerously-skip-permissions --resume

  test:
    desc: Run Helm tests (lint, template, unit tests)
    dir: chart
    cmds:
      - helm dependency update
      - helm lint .
      - helm template test . > /dev/null
      - echo "✅ Helm chart tests passed"

  schema:
    desc: Generate values.schema.json from values.yaml
    dir: chart
    cmds:
      - ./scripts/schema.sh

  package:
    desc: Package Helm chart locally
    dir: chart
    cmds:
      - |
        echo "📦 Packaging Helm chart..."
        helm dependency update
        helm package . --destination /tmp
        echo "✅ Chart packaged: /tmp/{{.CHART_NAME}}-{{.VERSION}}.tgz"

  login:
    desc: Login to container registry
    silent: true
    cmds:
      - |
        if [ -z "$DOCKER_PASSWORD" ]; then
          echo "❌ DOCKER_PASSWORD not set"
          exit 1
        fi
        echo "$DOCKER_PASSWORD" | helm registry login {{.REGISTRY}} -u "$DOCKER_USERNAME" --password-stdin
        echo "✅ Logged in to {{.REGISTRY}}"

  helm:push:
    desc: Package and push Helm chart to OCI registry
    deps: [login]
    dir: chart
    cmds:
      - |
        echo "📦 Packaging Helm chart..."
        helm dependency update
        helm package . --destination /tmp

        PACKAGE_FILE="/tmp/{{.CHART_NAME}}-{{.VERSION}}.tgz"

        echo "📤 Pushing chart to OCI registry..."
        helm push "$PACKAGE_FILE" "oci://{{.REGISTRY}}/{{.NAMESPACE}}/chart"

        # Clean up package file
        rm -f "$PACKAGE_FILE"

        echo "✅ Helm chart pushed to oci://{{.REGISTRY}}/{{.NAMESPACE}}/chart/{{.CHART_NAME}}:{{.VERSION}}"

  helm:pull:
    desc: Pull Helm chart from OCI registry
    deps: [login]
    cmds:
      - |
        echo "📥 Pulling chart from OCI registry..."
        helm pull "oci://{{.REGISTRY}}/{{.NAMESPACE}}/chart/{{.CHART_NAME}}" \
          --version "{{.VERSION}}" \
          --destination /tmp

        echo "✅ Chart downloaded to /tmp/{{.CHART_NAME}}-{{.VERSION}}.tgz"

  deploy:
    desc: Deploy Signal Desktop to Kubernetes
    deps: [regcred]
    cmds:
      - |
        helm upgrade --install signal \
          chart/ \
          --namespace signal \
          --create-namespace \
          --timeout 10m

        kubectl config set-context --current --namespace=signal
        echo "✅ Signal Desktop deployed"

  helm:deploy:
    desc: Deploy Signal Desktop from OCI registry
    deps: [login, regcred]
    cmds:
      - |
        echo "🚀 Deploying Signal Desktop from OCI registry..."

        helm upgrade --install signal \
          "oci://{{.REGISTRY}}/{{.NAMESPACE}}/chart/{{.CHART_NAME}}" \
          --version "{{.VERSION}}" \
          --namespace signal \
          --create-namespace \
          --timeout 10m

        kubectl config set-context --current --namespace=signal
        echo "✅ Signal Desktop deployed from OCI chart"

  regcred:
    desc: Create Docker registry credentials for image pulling
    silent: true
    internal: true
    status:
      - "[ -z \"$DOCKER_USERNAME\" ] || [ -z \"$DOCKER_PASSWORD\" ]"
    cmds:
      - kubectl create namespace signal || true
      - |
        kubectl create secret docker-registry regcred \
          --namespace signal \
          --docker-server={{.REGISTRY}} \
          --docker-username=$DOCKER_USERNAME \
          --docker-password=$DOCKER_PASSWORD \
          --dry-run=client -o yaml | kubectl apply -f -

  watch:
    desc: Watch Signal deployment
    cmds:
      - kubectl get pods --namespace signal --watch

  forward:
    desc: Forward ports to Signal VNC
    cmds:
      - |
        pkill -f "port-forward.*signal" 2>/dev/null || true
        kubectl port-forward --namespace signal svc/signal 6901:6901

  destroy:
    desc: Destroy Signal from Kubernetes
    cmds:
      - |
        echo "🗑️ Destroying Signal namespace..."
        kubectl delete namespace signal --grace-period=30 --ignore-not-found=true 2>/dev/null || true

        if kubectl get namespace signal 2>/dev/null | grep -q Terminating; then
          echo "⚠️ Namespace stuck in Terminating state, removing finalizers..."
          kubectl patch namespace signal -p '{"metadata":{"finalizers":[]}}' --type=merge 2>/dev/null || true
          kubectl delete namespace signal --force --grace-period=0 2>/dev/null || true
        fi

        if kubectl get namespace signal 2>/dev/null; then
          echo "❌ Failed to delete namespace, manual intervention may be required"
          exit 1
        else
          echo "✅ Signal namespace destroyed"
        fi

  version:bump:
    desc: Bump chart version (usage - task version:bump TYPE=major|minor|patch)
    silent: true
    vars:
      TYPE: '{{.TYPE | default "patch"}}'
    cmds:
      - |
        CURRENT=$(grep '^version:' chart/Chart.yaml | awk '{print $2}')
        echo "📌 Current version: ${CURRENT}"

        IFS='.' read -r MAJOR MINOR PATCH <<< "${CURRENT}"

        case "{{.TYPE}}" in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
          *)
            echo "❌ Invalid type. Use: major, minor, or patch"
            exit 1
            ;;
        esac

        NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
        echo "🔼 New version: ${NEW_VERSION}"

        sed -i "s/^version:.*/version: ${NEW_VERSION}/" chart/Chart.yaml

        echo "✅ Chart version bumped to ${NEW_VERSION}"
        echo ""
        echo "💡 Next steps:"
        echo "   1. Review the change: git diff chart/Chart.yaml"
        echo "   2. Commit: git add chart/Chart.yaml && git commit -m 'release: bump chart version to ${NEW_VERSION}'"
        echo "   3. Tag: git tag v${NEW_VERSION} && git push --tags"
        echo "   4. Push chart: task helm:push"

  changelog:
    desc: Generate CHANGELOG.md from git history
    silent: true
    cmds:
      - |
        if ! command -v git-chglog &> /dev/null; then
          echo "⚠️  git-chglog not found. Installing..."

          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH=$(uname -m)

          if [ "$ARCH" = "x86_64" ]; then
            ARCH="amd64"
          elif [ "$ARCH" = "aarch64" ]; then
            ARCH="arm64"
          fi

          VERSION="0.15.4"
          URL="https://github.com/git-chglog/git-chglog/releases/download/v${VERSION}/git-chglog_${VERSION}_${OS}_${ARCH}.tar.gz"

          echo "📥 Downloading git-chglog ${VERSION}..."
          mkdir -p ~/.local/bin
          curl -sL "$URL" | tar xz
          mv git-chglog ~/.local/bin/
          rm -f LICENSE README.md

          echo "✅ git-chglog installed"
        fi

        echo "📝 Generating CHANGELOG.md..."
        ~/.local/bin/git-chglog --output CHANGELOG.md
        echo "✅ CHANGELOG.md generated"
        echo ""
        echo "💡 Review: cat CHANGELOG.md"

  dev:
    desc: Setup FluxCD GitOps for k3d-ghostwire development cluster
    cmds:
      - |
        set -e

        REPO_OWNER="drengskapur"
        REPO_NAME="ghostwire"
        REPO_URL="ssh://git@github.com/${REPO_OWNER}/${REPO_NAME}"
        KEY_DIR="${HOME}/.ssh/flux-${REPO_NAME}"
        KEY_FILE="${KEY_DIR}/identity-dev"
        PUB_KEY_FILE="${KEY_FILE}.pub"
        FLUX_NAMESPACE="flux-system"
        SECRET_NAME="flux-system"
        CLUSTER_NAME="k3d-ghostwire"

        echo "🚀 Setting up FluxCD GitOps for ${CLUSTER_NAME}"
        echo ""

        # Check if gh CLI is available
        if ! command -v gh &> /dev/null; then
          echo "❌ gh CLI not found. Please install: https://cli.github.com/"
          exit 1
        fi

        # Check if authenticated
        if ! gh auth status &> /dev/null; then
          echo "❌ Not authenticated with GitHub. Run: gh auth login"
          exit 1
        fi

        # Check kubectl context
        CURRENT_CONTEXT=$(kubectl config current-context)
        if [ "$CURRENT_CONTEXT" != "$CLUSTER_NAME" ]; then
          echo "⚠️  Current context is '${CURRENT_CONTEXT}', switching to '${CLUSTER_NAME}'..."
          kubectl config use-context ${CLUSTER_NAME}
        fi

        # Step 1: Create SSH key pair if it doesn't exist
        if [[ -f "${KEY_FILE}" ]]; then
          echo "✓ SSH key pair already exists at ${KEY_FILE}"
        else
          echo "📝 Creating SSH key pair..."
          mkdir -p "${KEY_DIR}"
          ssh-keygen -t ed25519 -C "flux-${CLUSTER_NAME}" -f "${KEY_FILE}" -N ""
          chmod 600 "${KEY_FILE}"
          chmod 644 "${PUB_KEY_FILE}"
          echo "✅ Created SSH key pair at ${KEY_FILE}"
        fi
        echo ""

        # Step 2: Add deploy key to GitHub if not already present
        DEPLOY_KEY_TITLE="flux-${CLUSTER_NAME}"
        PUB_KEY_CONTENT=$(cat "${PUB_KEY_FILE}")

        echo "🔑 Checking GitHub deploy key..."
        EXISTING_KEY=$(gh api \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "/repos/${REPO_OWNER}/${REPO_NAME}/keys" \
          --jq ".[] | select(.title == \"${DEPLOY_KEY_TITLE}\") | .id" 2>/dev/null || echo "")

        if [[ -n "${EXISTING_KEY}" ]]; then
          echo "✓ Deploy key '${DEPLOY_KEY_TITLE}' already exists (ID: ${EXISTING_KEY})"
        else
          echo "📝 Adding deploy key to GitHub..."
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${REPO_OWNER}/${REPO_NAME}/keys" \
            -f "title=${DEPLOY_KEY_TITLE}" \
            -f "key=${PUB_KEY_CONTENT}" \
            -F "read_only=true" \
            > /dev/null
          echo "✅ Added deploy key '${DEPLOY_KEY_TITLE}' to GitHub"
        fi
        echo ""

        # Step 3: Create Kubernetes secret for Flux
        echo "🔐 Setting up Kubernetes secret..."

        # Check if namespace exists
        if ! kubectl get namespace "${FLUX_NAMESPACE}" &> /dev/null; then
          echo "📝 Creating namespace ${FLUX_NAMESPACE}..."
          kubectl create namespace "${FLUX_NAMESPACE}"
        fi

        # Create known_hosts entry for GitHub
        KNOWN_HOSTS=$(ssh-keyscan github.com 2>/dev/null)

        # Check if secret already exists
        if kubectl get secret "${SECRET_NAME}" -n "${FLUX_NAMESPACE}" &> /dev/null; then
          echo "✓ Secret '${SECRET_NAME}' already exists"
          echo "  Updating secret with current SSH key..."
          kubectl delete secret "${SECRET_NAME}" -n "${FLUX_NAMESPACE}"
        fi

        # Create secret
        kubectl create secret generic "${SECRET_NAME}" \
          --namespace="${FLUX_NAMESPACE}" \
          --from-file=identity="${KEY_FILE}" \
          --from-file=identity.pub="${PUB_KEY_FILE}" \
          --from-literal=known_hosts="${KNOWN_HOSTS}"

        echo "✅ Created/updated secret '${SECRET_NAME}' in namespace '${FLUX_NAMESPACE}'"
        echo ""

        # Step 4: Create image pull secret for GHCR
        echo "🔐 Checking image pull secret..."

        if [[ -n "${DOCKER_USERNAME:-}" && -n "${DOCKER_PASSWORD:-}" ]]; then
          echo "📝 Creating image pull secret for ghcr.io..."

          # Create flux-system image pull secret
          kubectl delete secret github-credentials -n flux-system &> /dev/null || true
          kubectl create secret docker-registry github-credentials \
            --namespace=flux-system \
            --docker-server=ghcr.io \
            --docker-username="${DOCKER_USERNAME}" \
            --docker-password="${DOCKER_PASSWORD}"

          echo "✅ Created image pull secret 'github-credentials' in namespace 'flux-system'"
        else
          echo "⚠️  Skipping image pull secret creation (DOCKER_USERNAME and DOCKER_PASSWORD not set)"
          echo "   To create it later, set DOCKER_USERNAME and DOCKER_PASSWORD in .env.local"
        fi
        echo ""

        # Step 5: Install Flux
        echo "⚙️  Setting up Flux installation..."

        # Check if Flux is already installed
        if flux check &> /dev/null; then
          echo "✓ Flux is already installed"
        else
          echo "📝 Installing Flux..."
          flux install
          echo "✅ Installed Flux components"
        fi
        echo ""

        # Step 6: Apply Flux configuration from develop/flux-system
        echo "📦 Applying Flux configuration..."
        kubectl apply -f develop/flux-system/
        echo "✅ Applied Flux configuration"
        echo ""

        # Step 7: Apply Helm repository and release
        echo "📦 Applying HelmRepository and HelmRelease..."
        kubectl apply -f develop/ghcr-helmrepo.yaml
        kubectl apply -f develop/helmrelease.yaml
        echo "✅ Applied Ghostwire configuration"
        echo ""

        echo "✅ FluxCD GitOps setup complete!"
        echo ""
        echo "📊 Current status:"
        flux get sources git
        echo ""
        flux get kustomizations
        echo ""
        flux get helmreleases -A
        echo ""
        echo "💡 Useful commands:"
        echo "  - Watch Flux reconciliation: flux logs --follow"
        echo "  - Force reconciliation: flux reconcile kustomization flux-system"
        echo "  - Check Flux status: flux check"
        echo "  - Watch pods: kubectl get pods -n ghostwire --watch"
